---
title: "C++中的构造，赋值，引用，移动"
description: "C++中的构造，赋值，引用，移动的区别和联系"
pubDate: "Feb 04 2025"
image: "/home.webp"
categories:

  - tech
tags:
  - C++
  - move
  - copy
---

# 一、（拷贝）构造，（拷贝）赋值，引用
<!-- ![](/profile.webp) -->
## 1.构造

构造即为一个实例对象分配空间以及初始化的过程

```
class Type
{
pubilc:
	int i;
	Type(int input)
	{
		i = input;
	}
}
```

类中仅含有i一个成员，Type的构造函数接收一个int参数并赋值给i。

注：这里的i不是严格意义的初始化，严格意义的初始化应为Type(int input):i(input){}

#### 构造一个Type实例对象:

##### 直接调用构造函数构造

```
Type inst(6);
//或：
Type inst{6};
//或:
Type inst = Type(6);
```

注：第三种初始化很像Type函数返回的临时对象创建后被拷贝或移动到 inst。在C++17以前语义确实如此，但大多数编译器会优化为Type inst(6)。C++17及以后该过程（即优化为Type inst(6)）写入标准被保证，即两者严格等价。

##### 从已有的对象（拷贝）构造

为此添加（拷贝）构造函数，它接收一个Type类对象作为参数

```
Type(Type other)
{
	this -> i = other.i;
}
```

使用:

```
Type a(6);
Type b(a);
```

第二行调用了b的（拷贝）构造

更进一步的，我们将（拷贝）构造函数优化为

```
Type(const Type other)//添加const确保被调用者的安全
{
	this -> i = other.i;
}
```

## 2.（拷贝）赋值

类对象的赋值是指将一个对象的值赋给另一个对象。

为实现该过程需要为类添加（拷贝）赋值函数（即重载”=“运算符）

```
void operator=(const test &other)
{
    this->i = other.i;
}
```

使用：

```
Type a(6);
Type b(0);
b = a;
```

在第三行触发了b的的赋值函数，将a的i赋值给了b的i

进一步的，为实现链式赋值（即a=b=c=d=……），优化为返回自身的引用

```
Type& operator=(const test &other)
{
    this->i = other.i;
    return *this;
}
```

注：赋值函数不强制使用“重载=”的形式，它既可以是全局函数也可以是成员函数，只要能达到“赋值”的目的即为赋值函数。

## 3. 引用

引用分为左值引用和右值引用，关于左值和右值参见[C++的那些事——左值、纯右值和将亡值 - 知乎](https://zhuanlan.zhihu.com/p/589182834)

引用即为指针常量的包装，本质上是指针的语法糖，目的是简化c语言中多级指针满天飞的场景，引用同样会有指针相似的问题（如悬空引用等），也可以理解为变量的“别名”

引用常用于替代指针、不可复制类型的传参、对象复用等

引用为C++内置语法，无需增添额外函数

创建引用时必须初始化

#### 左值引用

```\
Type a(6);
Type& b = a;
```

其中b为a的（左值）引用。

a,b操作同一变量，对a(b)的操作等价于对b(a)的操作

```
Type a(6);
Type& b = a;
std::cout<< a.i << " " << b.i <<"\n";//输出"6 6"
b.i++;
std::cout<< a.i << " " << b.i <<"\n";//输出"7 7"
```

引用不支持更改绑定对象（参照常量指针）

```
int main()
{
    T a(9);
    T b(100);
    T &c = a;
    c = b;//不是将c绑定的对象改为b而是将b赋值给c
    std::cout << a.i<<" " << b.i<<" " << c.i << '\n';
    return 0;
}
//输出:"100 100 100"
```

注：虽然引用本质是指针，但引用在 C++ 中是语言级的特性，并不会调用重载的 operator&。因此，即使你在类中禁用了 operator&（例如将其删除），引用仍能正确工作，不受影响。

注：Type& b = a（即绑定一个左值，这里是a）中不会为b分配{int i}的空间，也不会调用b的构造函数，同时也不会调用a的任何函数（如析构函数）,**左值引用引用左值不会更改被引用对象（这里是a）的生命周期，c++规定创建引用时必须初始化在一定程度上是为了确保引用的生命周期(即b)小于等于被引用的(即a)生命周期，以避免悬空引用。而指针不要求创建时初始化，使得经常出现悬空指针。引用相较于指针更安全，指针相较于引用更灵活（如动态绑定，晚绑定等）**

#### 右值引用

对右值进行的引用：

```
T fun()//函数的返回值为右值
{
    return T(1);
}

int main()
{
    T &&a = fun();//绑定一个右值,整个流程只会创建一次内存
    T b = fun();//创建并赋值,整个流程会创建两次内存
    std::cout<<a.i<<'\n';//合法，a的绑定延长了fun返回值临时变量的生命周期
    return 0;
}

```

注：同Type inst = Type(6)，T b = fun()在C++17以前会大概率被优化为T&& b = fun()，c++17以后必定被优化

**右值引用会延迟被引用的右值的生命周期至与该引用一致，如T &&a = fun()中a绑定了fun的临时返回值变量，按照标准fun的临时返回值变量应在该语句后析构，但由于a是该右值的引用，该临时对象的生命周期被提升为与a一致，使得对其操作合法**

#### 常量左引用绑定左值

被const修饰的引用不可修改所绑定的对象

```
Type a(6);
const Type& b = a;
a.i =10;//合法
b.i =10;//不合法
```

#### 常量左引用绑定右值

常量左引用既可以绑左值，也可以绑右值，绑定右值时等价于常量右引用

```
void fun(const T& a)//a既可以绑右值又可以绑左值
{
    std::cout << a.i << '\n';
}
int main()
{
    T a(1);
    fun(a);//a为左值
    fun(T(2));//T(2)为右值
    return 0;
}
```

#### 常量右引用

不可修改的右引用

```
T fun()
{
    return T(1);
}

int main()
{
    const T && a = fun();
    a.i = 10;//非法
    return 0;
}

```

注：常量右引用只能绑右值，常量左引用既能绑右值又能绑左值

# 二、移动

## 0.移动的意义



## 1.移动构造

考虑一个类：

```
class T
{
private:
    char *data;
    size_t len;

public:
    T(const char* input)
    {
        len = strlen(input);
        data = static_cast<char*>(malloc(len));
        strcpy(data, input);
    };
    ~T()
    {
        free(data);
    }
};

```

它的特点是同时含堆上内存（data*指向的内存和栈上内存（len）。

```
    T(const char* input)
    {
        len = strlen(input);
        data = static_cast<char*>(malloc(len));
        strcpy(data, input);
    };
```

通过一个字符串来构造

### 移动拷贝

```

```







但只要记住：

1. 移动适用于含堆上内存且无需再使用的类（右值），而赋值适用于所有类；
2. 含堆上内存的类必须禁用或重写拷贝构造函数、拷贝赋值函数。
3. 含堆上内存的类必须重写析构函数。

```c++
#include <iostream>
#include <utility>
#include <cstdlib>
#include <algorithm>
class T
{
	char* ptr = nullptr;
	T (const char* input)
	{
        strcpy()
    }
}
```



